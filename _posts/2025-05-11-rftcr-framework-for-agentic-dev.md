---
layout: post
title: RFTCR: RFTCR - 에이전트 주도 소프트웨어 개발을 위한 새로운 SDLC 프레임워크
excerpt: RFTCR: A new SDLC framework, RFTCR, for agentic software development
author: vincent
email: ldg55d@gmail.com
tags: ai agent agent-driven-development agentic-ide cursor vibe-coding
publish: true
---

## TL;DR

* **RFTCR** (Requirement-Feature-Task-Code-Reflect) 프레임워크는 에이전트가 코드를 작성하는 개발 방식에서 효과적인 가이드 역할을 한다.
* 이 프로세스의 실행에는 **프로덕트 오너/기획자**와 **개발자** 두 가지 역할의 긴밀한 협업이 필수적이다.
* 각 단계마다 역할별 요구를 지원하는 **전용 도구**(에이전트 기반 툴)가 필요하며, 일부 기능은 두 역할이 공통으로 활용한다.
* **C4 모델**처럼 단계별 **입력/출력의 추상화 수준을 명확히 정의**해야 프로세스가 표준화되고 재현 가능하며, 그렇지 않으면 개인 역량에 의존해 일관성을 잃게 된다.
* 궁극적으로 RFTCR은 **비즈니스 요구사항을 코드로 정확히 변환**하는 것을 목표로 하며, 각 산출물을 \*\*청사진(blueprint)\*\*으로 삼아 지식 수준에 관계없이 누구나 동일한 코드를 생성할 수 있도록 한다.

## 시작하며

소프트웨어 개발에서 AI **에이전트**의 역할이 커지면서, AI가 코드를 주도적으로 생성하고 사람이 이를 평가하는 **에이전트 주도 개발** 패러다임이 등장했습니다. 이러한 방식에서는 개발자가 코드를 직접 작성하기보다, **LLM**(거대 언어 모델) 기반의 AI가 코드를 만들고 개발자는 이를 검토 및 조율합니다. 하지만 초기 경험자들은 \*\*“AI에게 우리가 원하는 코드를 안정적으로 만들어내도록 가이드하기 어렵다”\*\*는 핵심 문제에 부딪칩니다. 한두 번의 프롬프트만으로 완벽한 결과를 얻기 힘들고, 요구사항이 조금만 모호해도 AI가 엉뚱한 방향으로 코드를 생성하기 일쑤입니다. 이러한 어려움을 해결하기 위해서는 AI를 효과적으로 \*\*조율(Orchestrate)\*\*할 수 있는 새로운 개발 프로세스와 도구들이 필요합니다.

필자는 이러한 배경에서 **RFTCR**이라는 새로운 SDLC(Software Development Life Cycle) 프레임워크를 고안했습니다. 이는 **Requirement → Feature → Task → Code → Reflect** 순으로 진행되는 5단계 프로세스로, 각 단계에서 명확한 산출물을 정의함으로써 AI 코딩 에이전트를 효율적으로 활용하도록 설계되었습니다. 실제 커뮤니티에서도 에이전트 기반 IDE 활용을 위해 “요구사항 → 기능 → 태스크 → 코드” 순의 작업 템플릿이 효과적이라는 사례가 등장하고 있습니다. 예를 들어 한 오픈소스 PRD 작성 도구에서는 에이전트가 질문을 주도하여 \*\*사용자는 답변만 하면 제품 요구사항 문서(PRD)\*\*가 완성되는데, 이때 활용된 템플릿이 바로 RFTC (요구사항→기능→태스크→코드) 구조였습니다. 이런 구조화된 접근 덕분에 AI가 실제 동작하는 코드를 만들어낼 가능성이 높아졌다고 합니다. 즉, RFTCR은 에이전트에게 명확한 가이드라인을 제시하여 **혼선 없이 원하는 결과물을 얻기 위한 베스트 프랙티스**라고 할 수 있습니다.

본 글에서는 RFTCR 프레임워크 각 단계를 자세히 살펴보고, 왜 이런 구조가 에이전트 주도 개발에 효과적인지 논의하겠습니다. 또한 \*\*프로덕트 오너(기획자)\*\*와 **개발자** 두 역할이 어떻게 이 프로세스에 관여하며, 단계별로 어떤 **도구(에이전트 기반 툴)** 지원이 필요한지도 설명합니다. 나아가 RFTCR가 성공적으로 정착하려면 왜 **명확한 추상화 수준 정의**가 필요한지, 그리고 이 접근이 어떻게 **역할 간 의존성을 줄이고** 코드 생성의 **안정성**을 높이며 **재현성**을 확보하는지도 강조하겠습니다.

## RFTCR 개요: 단계와 역할 분담

&#x20;*RFTCR 프로세스 개요: 요구사항(Requirement) → 기능(Feature) → 태스크(Task) → 코드(Code) → 리플렉션(Reflect)의 5단계를 거치며, 각 단계에는 프로덕트 오너/기획자(Planner)와 개발자(Developer)가 주체 또는 협업자로 참여한다. 파란색 상자는 기획자가 주로 이끄는 단계를, 녹색 상자는 개발자가 주도하는 단계를 나타낸다. 점선 화살표는 최종 단계인 Reflect에서 얻은 피드백이 다시 요구사항 단계로 돌아가 문서에 반영될 수 있음을 의미한다.*

RFTCR 프로세스는 **요구사항 → 기능 → 태스크 → 코드 → 리플렉션** 순으로 진행됩니다. 이때 각 단계를 수행하는 데 두 가지 역할이 관여하는데, 바로 \*\*프로덕트 오너(또는 기획자)\*\*와 **개발자**입니다. 기획자는 비즈니스 관점에서 *무엇을* 만들어야 하는지 정의하는 역할이고, 개발자는 기술적 관점에서 *어떻게* 만들지를 책임지는 역할입니다. RFTCR에서는 이 둘이 단계마다 명확한 \*\*산출물(artifact)\*\*을 주고받으며 협업합니다. 일반적인 소프트웨어 개발에서도 기획자와 개발자의 협력이 중요하지만, 에이전트 주도 개발에서는 이들이 만들어내는 산출물이 곧 AI 에이전트의 **프롬프트**가 되어 코드 생성 품질을 좌우하기 때문에, 역할 분담이 더욱 체계적이어야 합니다.

각 단계별로 누가 주도권을 가지는지는 다르지만, **모든 단계에 두 역할의 관여가 일부씩은 있습니다**. 예를 들어 요구사항 단계에서는 기획자가 주도적으로 문서를 작성하지만, 개발자도 초기 기술 검토나 피드백을 통해 관여합니다. 반대로 코드 단계에서는 개발자가 에이전트와 함께 코드를 생성하지만, 기획자가 큰 그림에서 우선순위를 조정하거나 산출물을 검증할 수 있습니다. 결국 RFTCR의 핵심은 \*\*“한 단계에 한 역할만 일방적으로 일하는 것이 아니라, 주관 역할이 있더라도 상대 역할의 관점을 함께 고려한다”\*\*는 것입니다. 이를 통해 추후 단계에서 뒤늦게 요구사항 미스매치나 기술적 문제를 발견하는 일을 줄이고, 처음부터 **역할 간 요구사항 충족과 기술 구현의 정합성**을 높일 수 있습니다.

이제 RFTCR의 각 단계를 순서대로 살펴보겠습니다. 각 단계마다 **어떤 일**을 하고 **어떤 산출물**을 만들며 **어떤 도구 지원**이 필요한지, 그리고 기획자와 개발자가 어떻게 협업하는지를 구체적으로 설명합니다.

### 1. 요구사항 단계 (Requirement)

첫 번째 단계는 **요구사항**을 명확히 정의하는 것입니다. 기획자가 중심이 되어 제품 또는 기능의 요구사항을 자연어로 작성합니다. 여기에는 비즈니스 목표, 사용자 스토리, 기능적/비기능적 요구사항, 제약 조건 등이 포함됩니다. 에이전트 주도 개발에서 요구사항 문서는 곧 **PRD (Product Requirement Document)** 역할을 하며, 이후 AI 에이전트에게 **지침서**로 제공됩니다. 경험상 초반의 요구사항 정의가 얼마나 구체적인지에 따라 이후 개발 속도와 방향이 크게 좌우됩니다. 불확실한 부분(변수)을 얼마나 **상수처럼 명확하게** 바꿔놓는지가 관건이며, RFTCR 프로세스에서도 이 단계에 충분한 시간을 투자해야 합니다. 요구사항을 잘 정의해두면 이후 단계에서 AI가 혼동을 일으킬 여지를 줄이고, 사람 간 커뮤니케이션 부담도 줄어듭니다.

이 단계의 **주요 산출물**은 정형화된 \*\*요구사항 명세서(PRD)\*\*입니다. 일반적인 PRD보다 한 단계 진화한 문서로 볼 수 있는데, 비즈니스 요구뿐만 아니라 주요 **기술 요구사항(TSD)**, \*\*아키텍처 결정(ADR)\*\*도 함께 담긴 포괄적인 사양서입니다. 이렇게 하는 이유는 에이전트에게 맥락을 충분히 제공하여, 나중에 코드 생성 시 불필요한 질문이나 혼선을 줄이기 위함입니다. 또한 프론트엔드/백엔드 등 여러 영역이 있다면 UI/UX 요구까지 포함해, 개발에 필요한 정보를 최대한 사전에 명시합니다.

> **도구 지원:** 요구사항 단계에서는 **PRD 작성 보조 도구**가 큰 도움이 됩니다. 예를 들어 AI가 자동으로 질문을 던져 기획자가 생각하지 못한 요구사항을 이끌어내고, 정해진 템플릿에 따라 문서를 완성해주는 에이전트 기반 툴을 활용할 수 있습니다. 실제 사례로, 한 오픈소스 PRD Writer는 사용자가 질문에 답하면 에이전트가 알아서 PRD 초안을 채워나가는 방식을 취했는데, 이를 통해 “**어떤 질문을 해야 하는지 막막함**”과 “**어디까지 작성해야 충분한지 모호함**” 문제를 해결했습니다. 또한 템플릿을 고정함으로써 문서의 완료 기준이 명확해지고, 작성자의 숙련도에 따라 품질이 들쭉날쭉해지는 현상도 줄였습니다. 이처럼 **PRD Writer**와 같은 도구는 기획자에게는 체계적인 가이드가 되고, 개발자에게는 일관된 형태의 요구사항을 제공하여 이후 단계를 수월하게 합니다. 나아가 PRD 작성 도구의 에이전트는 개발자의 관점도 일부 겸비하고 있어서, 설령 기획자가 기술 배경이 부족하더라도 최소한의 품질과 일관성을 유지해주는 장점이 있습니다.

요구사항 단계에서 중요한 것은 산출물의 **표준화**입니다. RFTCR를 적용하려면 PRD의 형식과 상세 수준이 일정 기준을 따라야 합니다. 각 요구사항에는 식별자나 우선순위, 수용 기준(AC) 등이 명확히 표시되고, 문장도 애매모호함 없이 구체적으로 작성되어야 합니다. 이렇게 해야 이후 단계(예: 기능 목록 도출 시)에서 AI나 사람이 혼선을 겪지 않습니다. 만약 이 단계의 산출물이 사람마다 제각각이라면, 에이전트에게 올바른 프롬프트를 주기 어렵고 결국 결과도 들쭉날쭉할 것입니다. **C4 모델**이 아키텍처 다이어그램의 계층별 내용과 범위를 표준화하여 팀간 소통을 원활하게 하듯이, RFTCR의 요구사항 산출물도 일정한 추상화 레벨과 형식을 따라야 합니다. 다음 단계인 기능 설계로 넘어갈 때, 이 명세서가 팀의 **공통 언어** 역할을 하도록 만드는 것이 이 단계의 목표입니다.

### 2. 기능 단계 (Feature)

두 번째 단계는 추려낸 요구사항을 구현할 **기능 단위로 묶고 설계**하는 과정입니다. 이 단계에서는 기획자와 개발자가 접점을 가지며 협업합니다. 요구사항 명세를 검토하면서, 관련된 요구사항들을 하나의 \*\*기능(Feature)\*\*이나 **모듈**로 그룹화하고, 각 기능에 대한 개략적인 **설계**를 도출합니다. 여기서 말하는 설계란 상세한 코드 설계가 아니라, 그 기능을 만족시키기 위한 **구성 요소와 동작 흐름**을 정의하는 것입니다. 마치 에픽(Epic)이나 사용자 스토리 수준에서 시스템의 동작을 서술하듯, 각 기능에 대해 “이 기능은 무엇을 하고 대략 어떻게 동작할 것이다”를 서술합니다. 이를 통해 요구사항과 구현 간의 **중간 다리**를 놓는 셈입니다.

**주요 산출물**은 각 기능별 **기능 명세서** 또는 **기술 스펙**입니다. 만약 요구사항 단계에서 만든 PRD가 전체 프로젝트에 대한 상위 문서라면, 기능 단계에서는 그것을 쪼개어 **여러 개의 하위 문서**를 만드는 과정이라고 볼 수 있습니다. 실제 현업에서도 방대한 요구사항을 하나의 문서에 담지 않고, 도메인이나 기능별로 구분하여 여러 문서로 관리하는 것이 효율적입니다. RFTCR 프로세스에서는 *요구사항 -> 기능* 단계 전환 시 이러한 **분할**이 일어나며, 각 기능 문서는 특정 요구사항 집합을 구현하기 위한 청사진 역할을 합니다. 예를 들어 “사용자 회원가입”이라는 기능에는 해당 기능과 관련된 요구사항(예: “이메일로 회원가입 가능해야 함”, “비밀번호 정책 준수” 등)을 모두 포함하고, 이를 충족시키기 위한 화면 흐름, API 개요, 데이터 모델 등의 설계 내용이 담길 수 있습니다.

> **도구 지원:** 기능 단계에서는 **기능 설계 보조 도구**나 **자동 스펙 생성기**를 활용할 수 있습니다. 요구사항 문서를 입력하면 AI가 알아서 관련 요구들을 클러스터링해 기능 목록을 제안하고, 각 기능에 대한 설계 초안을 작성해주는 식입니다. 앞서 언급한 PRD가 여러 개의 문서로 나뉘는 과정도 에이전트를 활용해 **자동화**할 수 있습니다. 실제 모범 사례에 따르면, 기능이 추가될 때마다 새로운 스펙 문서를 만들고 이를 최신 상태로 유지하는 작업을 에이전트에게 맡기는 것이 권장됩니다. 이를 위해 템플릿 기반으로 기능 문서를 생성하고, AI **리즈닝 모델**로 문서의 모호한 부분을 검수한 뒤 보완하는 접근도 제안됩니다. 요컨대 **Feature 단계의 도구**는 요구사항을 입력받아 표준화된 기능 설계서들을 출력함으로써, 개발자가 바로 구현 계획을 세울 수 있는 발판을 제공합니다. 이러한 도구는 기획자에게는 요구사항이 실제 구현 기능으로 맵핑되는 과정을 투명하게 보여주고, 개발자에게는 이후 태스크를 뽑아낼 수 있는 구조화된 자료를 제공합니다.

기능 단계의 핵심은 **요구사항을 구현 관점으로 재구조화**하는 것입니다. 이때 각 기능 설계는 너무 추상적이어도 안 되고, 너무 세세해서는 더 안 됩니다. 추상화 수준은 각 기능이 **독립적으로 이해**되고 **개발 착수 결정**을 할 정도면 충분합니다. 만약 이 단계를 건너뛰고 바로 요구사항에서 태스크로 옮겨가면, 태스크들이 산발적으로 쏟아져 나와 개발 우선순위 설정이나 영향 범위 파악이 어려워집니다. 기능 단위로 한 번 구조화해두면, 팀은 “어느 기능부터 개발할 것인가”, “기능 간 의존성은 무엇인가”를 논의할 수 있고, 에이전트에게도 한 번에 한 기능씩 초점을 맞춰 개발하도록 지시할 수 있습니다. 이는 마치 C4 모델에서 **Container 수준**의 그림을 그려놓고 컴포넌트 작업으로 들어가는 것과 유사합니다 – 큰 그림을 그린 후 세부 작업을 나누는 원리이지요.

### 3. 태스크 단계 (Task)

세 번째 단계는 각 기능을 실제로 구현하기 위한 **세부 태스크**를 도출하는 것입니다. 여기서는 개발자가 주도권을 가지며, 기획자는 보조적인 역할로 참여합니다. 기능 명세서를 기반으로 “이 기능을 만들기 위해 어떤 일들이 수행되어야 하는가?”를 구체적인 작업 목록으로 정리합니다. 태스크는 일반적으로 **개발자 관점의 할 일** 목록이며, 하나의 태스크는 하나의 함수 구현, 하나의 데이터베이스 변경, 또는 하나의 화면 구성처럼 **작은 단위**로 쪼개지는 것이 이상적입니다. 이렇게 쪼갠 이유는, 각 태스크를 AI 에이전트가 **한 번에 하나씩 처리**할 수 있게 하여 오류 발생 시 그 범위(블라스트 반경)를 최소화하기 위함입니다. 작은 단위로 격리하면 실패해도 영향이 제한적이고 관리 가능하기 때문에, 시스템의 안정성이 높아집니다. 실제로 잘 설계된 시스템은 장애가 발생해도 국소적인 영향에 그치도록 **blast radius**를 제한하는데, RFTCR의 태스크 분할 역시 동일한 맥락으로 볼 수 있습니다.

**주요 산출물**은 정리된 **태스크 목록**입니다. 이 목록은 우선순위, 예상 난이도, 담당자(사람 또는 에이전트), 그리고 태스크 별로 참조해야 할 세부 요구사항이나 설계 요소를 매핑해 놓은 형태일 것입니다. 예를 들어 “회원가입 API 개발” 기능 내에 “DB에 사용자 테이블 생성”, “회원가입 API 엔드포인트 구현”, “입력값 유효성 검증 로직 추가” 등의 태스크들이 나열됩니다. 각 태스크는 가급적 **독립적**으로 실행 가능하도록 작성되어, 병렬로 작업하거나 순차 진행 시에도 큰 간섭이 없도록 합니다. 이때 기획자는 각 태스크가 빼놓지 말아야 할 요구사항을 빠뜨리지 않았는지 확인해주거나, 우선순위가 비즈니스 가치와 align되게 정렬됐는지 피드백을 줄 수 있습니다. 즉, **개발자는 기술적 세분화**를, **기획자는 비즈니스적 타당성 검사**를 하는 식의 협업이 이뤄집니다.

> **도구 지원:** 태스크 단계에서는 **태스크 매니저(Task Manager)** 혹은 **AI 태스크 플래너** 도구가 활용될 수 있습니다. 이러한 도구는 기능 명세를 입력받아 자동으로 세부 작업들을 생성하거나, 개발자가 작성한 태스크 목록을 이해하여 다음 단계를 에이전트가 수행하기 쉽게 포맷팅해주는 역할을 합니다. 예를 들어, Anthropic의 Claude 등 LLM에는 `TaskList`나 `Taskmaster`와 같은 프롬프트 템플릿이 있어 요구사항으로부터 할 일을 뽑아내는 기능이 알려져 있는데, 이러한 방식을 전문화한 에이전트를 생각해볼 수 있습니다. 이 Task Manager 에이전트는 **체인-오브-소트(chain-of-thought)** 방식으로 “먼저 무엇을 하고, 다음에 무엇을 해야 하는지”를 단계별로 출력해주거나, 생성된 태스크들 사이의 **의존 관계**를 표시해줄 수도 있습니다. 또한 태스크 관리 도구는 기획자와 개발자가 **공동의 To-Do 리스트**를 보는 효과를 주기 때문에, 서로 역할은 달라도 지금 진행 중인 일과 남은 할 일이 투명하게 공유됩니다. 기획자는 완료된 태스크를 보며 “이 기능의 이 부분까지 구현됐다”를 파악하고, 개발자는 아직 정의되지 않은 모호한 태스크가 있다면 기획자와 상의해 분해하거나 수정하는 식으로 상호 작용하게 됩니다.

태스크 단계의 중요 포인트는 **세분화와 순서 결정**입니다. 태스크를 적절히 쪼개지 않으면 AI 코딩 단계에서 한 번에 너무 많은 것을 시도하게 되어 오류 가능성이 커집니다. 반대로 지나치게 잘게 쪼개면 전체 맥락이 분산되어 효율이 떨어질 수 있습니다. 경험적으로는 “한 번에 하나의 기능에 대해 PR 하나 또는 커밋 하나를 만들 수 있을 정도”의 크기가 적당합니다. 그리고 태스크 사이의 순서를 정해서 **에이전트 작업 플로우**를 설계해야 합니다. 예컨대 데이터베이스 스키마 설정 태스크가 API 구현 태스크보다 먼저 실행되도록 순서를 배치하고, UI 개발 태스크는 API 완료 후에 진행하는 식입니다. 이러한 순서도 AI에게 지시할 때 명시하거나, 또는 Task Manager 에이전트가 자동으로 태스크 처리 순서를 관리하도록 할 수 있습니다.

### 4. 코드 단계 (Code)

네 번째 단계는 실제 **코드 구현** 단계입니다. 개발자가 중심이 되어, 앞서 정리된 태스크들을 하나씩 처리하면서 코드를 작성합니다. 여기서 “개발자”는 인간 개발자와 AI 코딩 에이전트의 **혼합된 형태**라고 볼 수 있습니다. RFTCR의 코드 단계는 전통적인 개발에서 코딩하는 것과 역할은 비슷하지만, **에이전트 주도 개발**의 맥락에서는 AI가 코드를 생성하고 개발자는 이를 검토 및 수정하는 방식으로 진행됩니다. 즉, 각 태스크마다 개발자는 AI에게 프롬프트(맥락과 지시)를 주고 **코드 생성을 요청**하며, AI가 내놓은 코드를 리뷰하고 필요시 수정하거나 재프롬프트하는 과정을 거칩니다. 이때 잘 준비된 이전 단계의 산출물들(PRD, 기능 설계, 태스크 정의)은 AI에게 정확한 컨텍스트를 제공하여, 가능한 한 처음부터 올바른 코드가 나오도록 돕습니다.

**주요 산출물**은 말 그대로 **소스 코드**입니다. 구현된 기능별로 코드가 작성되고, 버전 관리 시스템(git 등)에 커밋됩니다. RFTCR의 철학은 코드 작성 중에도 *불확실성이나 추측을 최소화*하는 데 있습니다. 에이전트에게 필요한 정보(예: API 스펙, 데이터 모델, 비즈니스 규칙)는 이미 이전 단계 산출물에 충분히 있으므로, AI가 부정확한 상상력을 발휘할 여지를 줄입니다. 예를 들어 “회원가입 API 엔드포인트 구현” 태스크를 수행할 때, 이전 단계의 기능 설계서에 “이메일 중복 검사 로직”이나 “비밀번호 해싱 방식”이 명시돼있다면, AI는 그 지침에 따라 코드를 바로 작성할 수 있습니다. 만약 이런 명세가 없다면 AI는 추측으로 구현할 수 있고, 나중에 수정해야 할 가능성이 높아집니다. 따라서 **코드 단계 이전의 치밀한 준비**가 코드 단계의 효율과 정확도를 결정한다고 해도 과언이 아닙니다.

> **도구 지원:** 코드 단계에서는 **에이전틱 IDE** 또는 **코드 생성 에이전트**의 도움이 절대적입니다. 앞서 언급한 Cursor, Windsurf, GitHub Copilot X, Amazon CodeWhisperer Q 등 다양한 에이전트 개발 도구들이 여기에 속합니다. 이러한 도구는 IDE 환경에서 개발자 대신(혹은 보조하여) 코드를 생성하고, 대화형으로 수정 명령을 받아들이며, 필요한 경우 외부 문서를 참조해가며 코딩을 진행합니다. 예를 들어 Cursor와 같은 에이전틱 IDE에서는 PRD 등 **정적 문서 컨텍스트**를 미리 등록해두고, 채팅 또는 Composer 기능으로 “다음 태스크를 구현해줘”라고 지시하면 AI가 관련 코드를 작성해주는 시나리오가 가능합니다. 개발자는 생성된 코드를 읽어보고 논리나 스타일을 검토하며, 부족한 부분은 추가 프롬프트를 통해 개선하거나 직접 수정합니다. 또한 코드 단계에서는 **버전 관리 통합 도구**도 고려되는데, 에이전트가 직접 git commit을 작성하거나 Pull Request 설명을 만들어주는 등 개발 워크플로우를 원활하게 해주는 기능들입니다. 핵심은, 도구가 자동화를 제공하더라도 **최종 의사결정은 개발자가 쥐고 있는 것**입니다. 에이전트의 코드 제안을 수용할지 말지, 어느 부분을 수정할지는 개발자의 판단이며, 이때 기획자는 산출물이 요구사항에 부합하는지 확인하는 데 집중합니다. 경우에 따라 기획자가 코드 변경 내역이나 커밋 로그를 확인하면서 요구사항 충족 여부를 검증하고 피드백을 줄 수도 있습니다. 그러나 일반적으로 코드 단계에서는 개발자의 역할이 90% 이상이며, 기획자는 완전히 손을 떼고 있어도 문서와 테스트를 통해 나중에 검증할 수 있을 만큼 프로세스가 갖춰져 있습니다.

코드 단계에서 중요한 것은 **안정성과 일관성**입니다. 앞 단계에서 정의된 태스크 하나를 구현할 때, 해당 범위 이외의 코드는 변경하지 않도록 관리하는 것이 바람직합니다. 예를 들어 “사용자 테이블 생성” 태스크를 수행하면서, 사용자와 무관한 다른 테이블에 영향을 주는 변경을 하면 안 됩니다. 이를 위해 자연스럽게 **하나의 태스크 – 하나의 커밋** 원칙을 따르게 되며, 에이전트도 그 범위를 벗어나지 않도록 프롬프트를 세심히 구성해야 합니다. 이러한 원칙이 지켜지면 만약 버그나 문제가 생겨도 \*\*영향 범위(Blast Radius)\*\*가 작아져, 문제 해결에 걸리는 시간도 단축됩니다. 또한 코드 스타일이나 아키텍처 결정 사항은 프로젝트 전반에 일관되게 적용되어야 합니다. 만약 에이전트가 일관성 없는 코드를 생성하면, Reflect 단계에서 이를 잡아주긴 하겠지만 가능하면 코드 생성 시부터 지키도록 하는 게 효율적이겠죠. 이를 위해 코딩 표준이나 아키텍처 원칙도 에이전트에게 **규칙으로 제시**될 수 있습니다 (예: “리포지토리 패턴을 따를 것”, “컨트롤러에서는 비즈니스 로직 최소화” 등). 결국 코드 단계는 **RFTCR의 다른 모든 단계가 합쳐져 결실을 보는 단계**이며, 철저한 준비와 명확한 가이드 덕분에 에이전트가 안정적으로 코드를 생산해내는 것을 목표로 합니다.

### 5. 리플렉션 단계 (Reflect)

다섯 번째이자 마지막 단계는 **리플렉션(Reflect)** 단계입니다. 이 단계에서는 개발자가 주도하지만, 경우에 따라 기획자도 결과물을 확인하며 참여합니다. 리플렉션의 사전적 의미는 **“반영”** 혹은 \*\*“성찰”\*\*인데, 여기서는 개발 과정과 생성된 코드를 되돌아보고 부족한 부분을 개선하는 일련의 작업을 의미합니다. 구체적으로는 **테스트 및 검증**, **버그 수정**, **리팩토링**, 그리고 **문서 갱신** 등이 해당됩니다. 에이전트 주도 개발 과정에서는 이 Reflect 단계가 특히 중요합니다. 왜냐하면 AI가 생성한 코드가 처음부터 완벽할 수 없고, 실행해봐야 드러나는 버그나 성능 이슈, 혹은 비즈니스 요구 미스매치가 있을 수 있기 때문입니다. RFTCR 프로세스에서는 Reflect 단계를 통해 이러한 문제를 조기에 발견하고 수정합니다. **코드 생성의 책임을 AI에게 넘기는 대신, 검증과 개선의 책임은 사람이 끝까지 지는 형태**로 보면 됩니다.

**주요 산출물**은 여러 가지가 있을 수 있습니다. 먼저 **테스트 결과**(예: 통합테스트, 단위테스트 통과 여부, 시나리오 테스트 결과)가 있고, **버그 수정 커밋**이나 **리팩토링 커밋**도 Reflect 단계의 산출물입니다. 또한 중요한 산출물로 **업데이트된 문서**를 꼽을 수 있습니다. RFTCR 프로세스의 강력한 특징 중 하나는, 개발 중 발견된 모든 변화나 결정사항을 다시 상위 산출물(요구사항/기능 문서 등)에 \*\*반영(Reflect back)\*\*한다는 점입니다. 예를 들어 개발하면서 API 규격이 바뀌었다면 기능 명세서나 요구사항서에 해당 내용을 수정 추가하고, 만약 요구사항 자체가 변경되었다면 PRD를 업데이트합니다. 이렇게 하면 문서와 코드 간 **싱크를 맞춰** 지속적으로 최신의 상태를 유지할 수 있습니다. 실제 에이전트 개발 베스트프랙티스에서도 PRD 문서를 코드와 함께 지속적으로 업데이트하고 에이전트를 활용해 관리할 것을 권장하고 있습니다. 이처럼 Reflect 단계까지 거치면, 결과적으로 코드만 만들어지는 게 아니라 **문서까지 살아있는 상태로 유지**되므로, 향후 새로운 개발자나 에이전트가 투입되더라도 현재 시스템을 이해하고 동일한 결과물을 다시 만들어내기 쉬워집니다.

> **도구 지원:** Reflect 단계에서는 **테스트 자동화 도구**와 **코드 분석 에이전트**, 그리고 **문서 업데이트 에이전트** 등이 큰 역할을 합니다. 우선 Continuous Integration(CI) 파이프라인 상에서 자동으로 테스트를 실행하고 결과를 보고해주는 도구는 필수입니다. AI 에이전트가 생성한 코드라 하더라도 전통적인 테스트의 중요성은 변함없으며, 오히려 더 중요할 수 있습니다. 그리고 **테스트 주도 에이전트** 또는 **디버그 에이전트**를 활용하여, 실패한 테스트 케이스나 런타임 에러 로그를 해석하고 원인을 짚어주는 것도 가능합니다. 예를 들어 “이러이러한 에러가 났는데, 어디를 고치는 게 좋을까?”를 묻는 프롬프트에 따라 AI가 디버깅 방향을 제안할 수 있습니다. 또한 **코드 리뷰봇**을 통해 코드 품질을 점검받고 개선할 부분(중복 코드 제거, 구조 개선 등)을 리스트업할 수도 있습니다. 마지막으로 문서 갱신에는, 개발자가 변경 사항을 요약해서 에이전트에 전달하면 해당 내용을 관련 문서 섹션에 통합해주는 **문서 보조 에이전트**가 있을 수 있습니다. 이는 일종의 AI 비서가 “PRD v1.3 -> v1.4 변경사항 반영 완료”처럼 문서를 최신화해주는 시나리오입니다. 이러한 도구들은 모두 **개발자의 Reflect 작업을 가속**하고, 빠뜨리는 부분 없이 체계적으로 정리하도록 돕는 역할입니다.

Reflect 단계를 거치면서 RFTCR의 한 사이클은 완료됩니다. 그러나 실제 개발은 반복(iterative)되기 마련입니다. 새로운 요구사항이 추가되거나 변경이 생기면, 다시 Requirement 단계로 돌아가서 해당 부분을 갱신하고 다음 사이클을 시작하면 됩니다. RFTCR의 각 단계 산출물이 체계적으로 쌓여 있다면, 어느 시점에 누가 작업을 이어받더라도 **동일한 청사진 아래에서 코드를 생성**할 수 있습니다. 이는 마치 레고 블럭 조립 설명서와 같아서, 문서(설명서)만 있다면 새로운 사람이나 AI도 같은 결과물(레고 완성품)을 만들 수 있다는 의미입니다. RFTCR 프로세스가 지향하는 바는 바로 이런 **지속 가능한 개발 사이클**입니다. 문서와 코드, 테스트가 항상 동기화되어 있으므로 유지보수나 기능 추가 시에 과거 결정을 잊어버리거나 잘못 이해해서 생기는 시행착오를 줄여줍니다. 그리고 작은 단위로 반영과 수정을 거치므로 \*\*문제의 파급 범위(Blast Radius)\*\*도 작게 유지되어, 어느 한 부분을 고쳐도 다른 부분에 미치는 영향이 최소화됩니다. 이는 곧 **안정적인 코드베이스**와 **예측 가능한 개발 프로세스**를 의미합니다.

## RFTCR의 효과: 안정성, 역할 분리, 재현성

앞서 각 단계별로 살펴본 내용을 바탕으로, RFTCR 프레임워크가 가져오는 **실질적 효과**들을 정리해보겠습니다.

* **에이전트를 활용한 안정적 개발:** RFTCR는 AI 에이전트를 활용한 개발의 불확실성을 구조적으로 줄여줍니다. 요구사항-기능-태스크처럼 점진적 분할과 맥락 제공 방식을 취함으로써, AI에게 **명확한 목표**를 제시하고 한 번에 다루는 범위를 제한합니다. 이는 LLM이 지닌 혼동이나 탈선 가능성을 낮춰주어, 에이전트가 코드 생성 책임을 지되 **안정적으로 원하는 코드를 뽑아내도록** 돕습니다. 예를 들어 명확한 PRD와 세분화된 태스크가 존재하는 경우, AI는 한정된 영역에서 코드를 작성하므로 실수 확률이 줄고, 혹여 실수가 나와도 국소적이라 쉽게 교정할 수 있습니다.

* **두 역할 간 최소한의 의존성:** RFTCR 프로세스는 **기획자와 개발자의 역할 구분**을 분명히 하면서도, 단계 산출물을 통해 간접 소통하게 해줍니다. 각 단계 산출물이 표준화되어 있기 때문에, 개발자는 기획자를 찾아가 구두로 설명을 듣지 않아도 문서를 통해 요구를 파악할 수 있고, 기획자도 개발 진행 상황을 문서와 태스크 보드를 통해 확인할 수 있습니다. 이는 **동시 협업**을 가능하게 하고, 한쪽이 부재하더라도 다른 쪽이 진행을 이어가기 쉽게 만듭니다. 결과적으로 **역할 간 의존도를 낮추어** 서로의 업무 진행에 병목이 생기는 일을 줄여줍니다. 물론 이는 두 사람이 각자 할 일을 하고 소통은 안 한다는 뜻이 아니라, 오히려 **산출물을 통한 투명한 협업**으로 불필요한 직접 의사소통 횟수를 줄인다는 의미입니다. 서로 간에 명확한 계약(Contract)이 존재하므로 신뢰하고 맡길 수 있게 되는 것입니다.

* **작은 변경으로 큰 안정성:** RFTCR의 단계 쪼개기와 작업 분할은 \*\*“작은 폭의 변경을 누적하여 큰 시스템을 완성”\*\*하는 철학과 통합니다. 이는 전통적인 애자일의 스프린트 또는 CI/CD의 지속적 배포와도 닿아있지만, RFTCR는 이를 에이전트 활용 개발에 맞게 최적화했습니다. 작은 단위의 변경은 문제 발생 시 **영향 범위**를 제한하여 장애를 쉽게 관리하게 합니다. 또 변경점이 작으니 코드 리뷰나 테스트도 국소적으로 시행할 수 있어 품질 보증에 유리합니다. 예를 들어 한번에 거대한 기능을 몽땅 생성하는 대신, 태스크 하나하나 완료하면서 통합하는 방식을 취하므로, 어느 지점에서 문제가 생기면 그 부분만 롤백하거나 수정하면 됩니다. **에러 처리**도 이러한 미세 단위 접근 덕분에 수월합니다. RFTCR 프로세스 하에서는 에이전트도 “어디서부터 잘못됐는지”를 좁은 맥락 안에서 파악할 수 있어 디버깅 프롬프트에 유리합니다. 이러한 방식은 결과적으로 **높은 안정성**과 **신뢰도**를 갖춘 개발 프로세스를 구현합니다.

* **표준화된 산출물을 통한 재현성:** 마지막으로, RFTCR의 큰 강점은 **개발 결과의 재현성**입니다. 각 단계별 산출물이 일종의 **청사진(blueprint)** 역할을 하기 때문에, 동일한 산출물을 입력받으면 **누가 실행하더라도 유사한 결과**를 얻을 수 있습니다. 예를 들어 현재 팀의 개발자가 아닌 새로운 사람이 투입되거나, 혹은 더 발전된 AI 모델이 나와 교체되더라도, RFTCR 산출물(업데이트된 PRD, 기능 명세, 태스크 리스트 등)을 따라가면 동일한 코드를 생성할 수 있어야 합니다. 이는 인적 지식에 의존하는 부분을 최소화하고 프로세스와 아티팩트에 지식을 담아두는 것이기에 가능한 일입니다. 특히 Reflect 단계까지 거치며 문서가 최신화되기 때문에, 코드와 문서 사이에 갭이 없고 \*\*단일 진실 공급원(Single Source of Truth)\*\*이 유지됩니다. 결과적으로 RFTCR를 준수하는 프로젝트는 유지보수나 포크(fork)하여 재구축할 때 비용이 낮아집니다. 마치 버전이 관리된 **소프트웨어 설계도면**을 가지고 있는 셈이라, 완전히 처음부터 다시 만들어도 같은 결과가 나올 정도의 **표준화**와 **재현 가능성**을 확보하는 것이 궁극적인 목표입니다.

## 맺으며

에이전트 주도 개발은 소프트웨어 엔지니어링의 새로운 지평을 열고 있습니다. 그러나 AI 에이전트의 **능동적 참여**가 아무리 혁신적이라도, 이를 이끌어가는 것은 여전히 **사람의 몫**입니다. RFTCR 프레임워크는 사람(기획자와 개발자)이 AI를 효과적으로 통제하고 협업하기 위한 **과정(Process)의 역할**을 합니다. 요구사항에서 코드에 이르는 다섯 단계의 **명확한 가이드 레일**을 제공함으로써, 우리는 AI의 창의성을 통제 가능한 형태로 끌어내고 비즈니스 가치를 정확히 실현하는 코드를 얻을 수 있습니다. 각 단계 산출물이 표준화되고 축적될수록 프로세스는 **반복할수록 더 빨라지고 견고**해질 것입니다.

물론 RFTCR도 초기에는 팀의 문화 정착과 도구 지원의 미비 등 넘어야 할 산이 있을 수 있습니다. 그러나 애자일이나 DevOps가 그랬듯이, 한 번 효과를 체감하면 돌아가기 힘들 정도의 생산성 향상과 품질 안정화를 가져올 것입니다. 중요한 것은 **추상화 수준을 맞춘 올바른 도구의 조합**과 **팀원들의 합의된 작업 방식**입니다. 이를 갖춘 RFTCR 프로세스는 에이전트 시대의 소프트웨어 개발을 한층 **표준화되고 예측 가능하며, 협업 친화적**인 활동으로 만들어줄 것입니다. 새로운 시대에는 새로운 방법론이 필요합니다. RFTCR가 그 해답의 하나가 되어, 에이전트와 사람이 함께 만드는 소프트웨어 개발이 혼돈에서 질서로 나아가길 기대합니다.